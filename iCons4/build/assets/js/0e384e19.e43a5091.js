"use strict";(self.webpackChunki_cons_4=self.webpackChunki_cons_4||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,g=m["".concat(l,".").concat(d)]||m[d]||p[d]||i;return n?r.createElement(g,o(o({ref:t},c),{},{components:n})):r.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:1},o="Rust Programming Language",s={unversionedId:"intro",id:"intro",title:"Rust Programming Language",description:"Introduction",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/iCons/iCons4/build/docs/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"RUST + C Trace",permalink:"/iCons/iCons4/build/docs/category/rust--c-trace"}},l={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:2},{value:"1. Memory Safety",id:"1-memory-safety",level:3},{value:"2. Concurrency",id:"2-concurrency",level:3},{value:"3. Zero-cost Abstractions",id:"3-zero-cost-abstractions",level:3},{value:"4. Ownership System",id:"4-ownership-system",level:3},{value:"5. Pattern Matching",id:"5-pattern-matching",level:3},{value:"6. Cargo",id:"6-cargo",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Variables and Mutability",id:"variables-and-mutability",level:3},{value:"Functions",id:"functions",level:2}],c={toc:u},m="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"rust-programming-language"},"Rust Programming Language"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Rust is a statically-typed systems programming language known for its emphasis on memory safety, zero-cost abstractions, and high performance. It was first developed by Mozilla and released in 2010. Rust's design goals include providing a safe and concurrent alternative to C and C++, while maintaining low-level control over hardware and system resources."),(0,a.kt)("p",null,"This document provides an extensive overview of Rust, covering its core features, syntax, memory management, and unique aspects that set it apart from other programming languages."),(0,a.kt)("h2",{id:"key-features"},"Key Features"),(0,a.kt)("h3",{id:"1-memory-safety"},"1. Memory Safety"),(0,a.kt)("p",null,"Rust's most significant feature is its focus on memory safety. It eliminates common programming errors like null pointer dereferences and buffer overflows through its ownership system, borrow checker, and lifetime annotations. These mechanisms ensure that memory-related bugs are caught at compile time, rather than causing runtime errors."),(0,a.kt)("h3",{id:"2-concurrency"},"2. Concurrency"),(0,a.kt)("p",null,"Rust has built-in support for concurrent programming, making it easier to write safe and efficient concurrent code. The ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," keywords allow for asynchronous programming, while Rust's ownership system ensures that data races and deadlocks are prevented."),(0,a.kt)("h3",{id:"3-zero-cost-abstractions"},"3. Zero-cost Abstractions"),(0,a.kt)("p",null,'Rust provides high-level abstractions without sacrificing performance. The "zero-cost" philosophy means that abstractions like generics, traits, and pattern matching don\'t introduce runtime overhead.'),(0,a.kt)("h3",{id:"4-ownership-system"},"4. Ownership System"),(0,a.kt)("p",null,"Rust's ownership system is the foundation of its memory safety guarantees. It revolves around three key concepts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Ownership"),': Each value in Rust has a single "owner" variable, which is responsible for cleaning up the value when it\'s no longer needed.')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Borrowing"),": Multiple references (either mutable or immutable) to a value can exist simultaneously, but they must follow strict rules to prevent data races.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Lifetimes"),": Lifetimes annotate how long references are valid, ensuring that references don't outlive the data they point to."))),(0,a.kt)("h3",{id:"5-pattern-matching"},"5. Pattern Matching"),(0,a.kt)("p",null,"Rust's pattern matching allows concise and expressive code for handling complex data structures. It's used extensively in control flow and destructuring."),(0,a.kt)("h3",{id:"6-cargo"},"6. Cargo"),(0,a.kt)("p",null,"Cargo is Rust's package manager and build tool. It simplifies dependency management, building, testing, and publishing Rust projects. It also enforces conventions, making it easy to create and share libraries."),(0,a.kt)("h2",{id:"syntax"},"Syntax"),(0,a.kt)("p",null,"Rust's syntax is similar to C and C++, but with some distinctive features:"),(0,a.kt)("h3",{id:"variables-and-mutability"},"Variables and Mutability"),(0,a.kt)("p",null,"In Rust, variables are immutable by default. To make a variable mutable, you must explicitly declare it as such using the ",(0,a.kt)("inlineCode",{parentName:"p"},"mut")," keyword:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let x = 42;         // Immutable variable\nlet mut y = 42;     // Mutable variable\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("p",null,"Functions in Rust are defined using the fn keyword. They can take parameters and return values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("Hello");    // s1 owns the String\n    let s2 = s1;                       // Ownership transferred to s2, s1 is no longer valid\n    // println!("{}", s1);             // This would result in an error\n\n    let s3 = String::from("World");\n    let len = calculate_length(&s3);   // Borrowing s3 immutably\n    println!("Length of \'{}\' is {}.", s3, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n')))}p.isMDXComponent=!0}}]);